<?php

/**
 * @file
 * The Commerce Invoice module.
 */

use Drupal\commerce_invoice\Entity\Invoice;
use Drupal\commerce_invoice\Entity\InvoiceController;
use Drupal\commerce_invoice\Entity\InvoiceMetadataController;
use Drupal\commerce_invoice\Entity\InvoiceNumberPattern;
use Drupal\commerce_invoice\InvoiceNumber\InvoiceNumber;

/**
 * Implements hook_entity_info().
 */
function commerce_invoice_entity_info() {
  $entities = [];

  $entities['commerce_invoice'] = [
    'label' => t('Commerce Invoice'),
    'base table' => 'commerce_invoice',
    'revision table' => 'commerce_invoice_revision',
    'fieldable' => TRUE,
    'label callback' => 'commerce_invoice_label',
    'entity keys' => [
      'id' => 'invoice_id',
      'bundle' => 'type',
      'revision' => 'revision_id',
    ],
    'bundles' => [
      'commerce_invoice' => [
        'label' => t('Invoice'),
        'admin' => [
          'path' => 'admin/commerce/config/invoice',
          'access arguments' => ['administer commerce_invoice entities'],
        ],
      ],
    ],
    'entity class' => Invoice::class,
    'controller class' => InvoiceController::class,
    'metadata controller class' => InvoiceMetadataController::class,
    'views controller class' => 'EntityDefaultViewsController',
    'access callback' => 'commerce_entity_access',
    'access arguments' => [
      'user key' => 'uid',
      'access tag' => 'commerce_invoice_access',
    ],
    'permission labels' => [
      'singular' => t('invoice'),
      'plural' => t('invoices'),
    ],
    'uri callback' => 'commerce_invoice_uri',
  ];

  $entities['commerce_invoice_number_pattern'] = [
    'label' => t('Invoice number pattern'),
    'base table' => 'commerce_invoice_number_pattern',
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => InvoiceNumberPattern::class,
    'entity keys' => [
      'id' => 'name',
      'name' => 'name',
      'label' => 'label',
      'status' => 'status',
    ],
    'exportable' => TRUE,
    'fieldable' => FALSE,
    'module' => 'commerce_invoice',
    'access callback' => 'commerce_invoice_number_pattern_access',
    'views controller class' => 'EntityDefaultViewsController',
    'admin ui' => [
      'path' => 'admin/commerce/config/invoice/numbers',
      'file' => 'commerce_invoice.admin.inc',
    ],
  ];

  return $entities;
}

/**
 * Label callback for an invoice.
 *
 * @param \Drupal\commerce_invoice\Entity\Invoice $invoice
 *
 * @return string
 */
function commerce_invoice_label(Invoice $invoice) {
  return $invoice->getInvoiceNumber()->__toString();
}

/**
 * Access callback for invoice number patterns.
 *
 * @return bool
 */
function commerce_invoice_number_pattern_access() {
  return user_access('administer commerce_invoice entities');
}

/**
 * Implements callback_entity_info_uri().
 *
 * @param Invoice $invoice
 *
 * @return string
 */
function commerce_invoice_uri(Invoice $invoice) {
  return ['path' => 'admin/commerce/invoices/' . $invoice->invoice_id];
}

/**
 * Checks invoice access for various operations.
 *
 * @param string      $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param object|NULL $invoice
 *   Optionally an invoice to check access for.
 * @param object|NULL $account
 *   The user to check for. Leave it to NULL to check for the current user.
 *
 * @return bool
 */
function commerce_invoice_access($op, $invoice = NULL, $account = NULL) {
  return commerce_entity_access($op, $invoice, $account, 'commerce_invoice');
}

/**
 * Implements hook_query_TAG_alter().
 *
 * @param \QueryAlterableInterface $query
 */
function commerce_invoice_query_commerce_invoice_access_alter(QueryAlterableInterface $query) {
  commerce_entity_access_query_alter($query, 'commerce_invoice');
}

/**
 * Implements hook_permission().
 */
function commerce_invoice_permission() {
  return commerce_entity_access_permissions('commerce_invoice');
}

/**
 * A list of invoice statuses.
 *
 * @return string<string>
 *   Invoice statuses keyed by their machine name.
 */
function commerce_invoice_statuses() {
  $statuses = [
    'pending' => t('Pending payment'),
    'paid' => t('Paid'),
    // @todo canceled, etc.
  ];

  drupal_alter(__FUNCTION__, $statuses);

  return $statuses;
}

/**
 * Load an invoice number pattern by machine name.
 *
 * @param string $name
 *
 * @return InvoiceNumberPattern|FALSE
 */
function commerce_invoice_number_pattern_load($name) {
  $patterns = entity_load_multiple_by_name('commerce_invoice_number_pattern', [$name]);

  return reset($patterns);
}

/**
 * Implements hook_default_commerce_invoice_number_pattern().
 */
function commerce_invoice_default_commerce_invoice_number_pattern() {
  $entity_type = 'commerce_invoice_number_pattern';
  $patterns = [];

  $patterns['consecutive'] = entity_create($entity_type, [
    'name' => 'consecutive',
    'label' => 'Consecutive',
    'pattern' => InvoiceNumber::SEQUENCE_TOKEN,
  ]);

  $patterns['daily'] = entity_create($entity_type, [
    'name' => 'daily',
    'label' => 'Daily',
    'pattern' => '[date:custom:Y]-[date:custom:m]-[date:custom:d]',
  ]);

  $patterns['monthly'] = entity_create($entity_type, [
    'name' => 'monthly',
    'label' => 'Monthly',
    'pattern' => '[date:custom:Y]-[date:custom:m]',
  ]);

  $patterns['yearly'] = entity_create($entity_type, [
    'name' => 'yearly',
    'label' => 'Yearly',
    'pattern' => '[date:custom:Y]',
  ]);

  return $patterns;
}

/**
 * Implements hook_theme().
 */
function commerce_invoice_theme() {
  return [
    'commerce_invoice_number' => [
      'variables' => [
        'invoice_number' => NULL,
        'key' => NULL,
        'pattern_name' => NULL,
        'sequence' => NULL,
        'sanitize' => TRUE,
      ],
      'file' => 'commerce_invoice.theme.inc',
    ],
  ];
}

/**
 * Implements hook_views_api().
 */
function commerce_invoice_views_api() {
  return ['api' => 3];
}

/**
 * Create a new invoice based on a Commerce order.
 *
 * @param object               $order
 *   A Commerce order.
 * @param InvoiceNumberPattern|NULL $pattern
 *   An invoice number pattern.
 * @param bool                 $save_order_revision
 *   Whether to create a new order revision before saving the invoice.
 *
 * @return \Drupal\commerce_invoice\Entity\Invoice
 *   A saved invoice entity.
 */
function commerce_invoice_create_from_order($order, InvoiceNumberPattern $pattern = NULL, $save_order_revision) {
  $original_revision_id = $order->revision_id;

  if ($save_order_revision) {
    $order->revision = TRUE;
    $order->log = t('New revision for invoicing');
    $order->revision_uid = 0;
    commerce_order_save($order);
  }

  /** @var \Drupal\commerce_invoice\Entity\Invoice $invoice */
  $invoice = entity_create('commerce_invoice', []);
  $invoice->order_id = $order->order_id;
  $invoice->order_revision_id = $original_revision_id;
  $invoice->uid = $order->uid;
  $pattern = $pattern ?: InvoiceNumberPattern::getDefault();
  $invoice->number_pattern = $pattern->name;

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  foreach ($order_wrapper->commerce_line_items->value() as $line_item) {
    $invoice_item = clone $line_item;
    $invoice_item->line_item_id = NULL;
    commerce_line_item_save($invoice_item);
    $invoice->wrapper()->commerce_invoice_items[] = $invoice_item;
  }

  $invoice->wrapper()->commerce_invoice_total = $order_wrapper->commerce_order_total->value();

  entity_save('commerce_invoice', $invoice);

  return $invoice;
}

/**
 * Determine whether an order has changed since its latest invoice.
 *
 * @param object $order
 *   The Commerce order object.
 *
 * @return bool
 *   TRUE if the order has changed since the last invoice, FALSE otherwise.
 */
function commerce_invoice_order_changed($order) {
  $invoice = commerce_invoice_load_last_for_order($order);
  if (!$invoice) {
    return TRUE;
  }

  // @todo this needs to be actually logical...
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $total_changed = $invoice->wrapper()->commerce_invoice_total->value() != $order_wrapper->commerce_order_total->value();

  return $total_changed;
}

/**
 * Load the most recent invoice for an order.
 *
 * @param object $order
 *   The Commerce order object.
 *
 * @return Invoice|FALSE
 *   The most recent invoice, or FALSE if none is found.
 */
function commerce_invoice_load_last_for_order($order) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_invoice');
  $query->propertyOrderBy('created', 'DESC');
  $query->propertyCondition('order_id', $order->order_id);
  $query->range(0, 1);
  $result = $query->execute();
  if (!empty($result['commerce_invoice'])) {
    $id = key($result['commerce_invoice']);

    return entity_load_single('commerce_invoice', $id);
  }

  return FALSE;
}

/**
 * Implements hook_menu().
 */
function commerce_invoice_menu() {
  $items = [];

  $items['admin/commerce/config/invoice'] = [
    'title' => 'Invoice settings',
    'description' => 'Configure fields and other settings for invoices.',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['commerce_invoice_settings_form'],
    'access arguments' => ['administer commerce_invoice entities'],
    'file' => 'commerce_invoice.admin.inc',
  ];

  $items['admin/commerce/invoices/%entity_object'] = [
    'load arguments' => ['commerce_invoice'],
    'title callback' => 'commerce_invoice_title',
    'title arguments' => [3],
    'page callback' => 'entity_ui_entity_page_view',
    'page arguments' => [3],
    'access callback' => 'commerce_invoice_access',
    'access arguments' => ['view', 3],
  ];

  return $items;
}

/**
 * Menu title callback for an invoice.
 *
 * @param Invoice $invoice
 *
 * @return string
 */
function commerce_invoice_title(Invoice $invoice) {
  return t('Invoice @number', ['@number' => $invoice->getInvoiceNumber()->__toString()]);
}

/**
 * Ensure required fields are present on invoices.
 */
function commerce_invoice_ensure_fields() {
  module_load_include('inc', 'commerce_invoice', 'commerce_invoice.fields');
  foreach (commerce_invoice_required_field_bases() as $field) {
    if (!field_info_field($field['field_name'])) {
      field_create_field($field);
    }
  }

  foreach (commerce_invoice_required_field_instances() as $instance) {
    if (!field_info_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
      field_create_instance($instance);
    }
  }
}
